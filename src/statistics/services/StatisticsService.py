import uuidimport shutilimport pandas as pdfrom flask import jsonimport osfrom src.statistics.config.config import get_upload_dir_path, get_assets_urlfrom werkzeug.utils import secure_filenameimport matplotlib.pyplot as pltfrom src.statistics.models.Statistics import Statisticsfrom src.statistics.models.UploadedFile import UploadedFileimport hashlibclass StatisticsServiceException(Exception):    passclass Storage:    def __init__(self, dir):        self.__dir = dir        self.__path = os.path.join(get_upload_dir_path(), dir)    def exist(self, filename =""):        path = os.path.join(self.__path,filename)        if os.path.isdir(path) or os.path.isfile(path):            return True        return False    @staticmethod    def create(dir):        storage = Storage(dir)        if not os.path.isdir(storage.__path):            os.mkdir(storage.__path)            return storage        else:             raise StatisticsServiceException("Statistics for this file already exist")    def remove(self, filename=""):        path = os.path.join(self.__path,filename)        if os.path.isdir(path):            shutil.rmtree(os.path.join(self.__path,filename), ignore_errors=True)        if os.path.isfile(path):            os.remove(path)    def generateUrl(self, filename):        return (get_assets_url() + self.__dir + "/" + filename).strip("/")    def generateSystemPath(self, filename):        return os.path.join(self.__path, filename)class FileHash():    def generate(self, fileStorage):        checksum = hashlib.md5(fileStorage.read()).hexdigest()        fileStorage.seek(0)        return checksumclass StatisticsService():    def __init__(self, fileHash = FileHash()):        self.fileHash= fileHash    def create(self, uow, file, name, description, separator):        checksum = self.fileHash.generate(file)        self.__storage = Storage.create(checksum)        try:            filename = secure_filename(file.filename)            fullFilePath = self.__storage.generateSystemPath(filename)            file.save(fullFilePath)            df = self.__loadDataFrames(fullFilePath, separator)            data = self.__processDataFrame(df)            fileModel = UploadedFile(name=filename,size=os.path.getsize(fullFilePath),row=len(df.index),                                     column=len(df.columns), checksum=checksum)            model = Statistics(name=name,description=description, data_description=data, file=fileModel)            valid, msg = model.validate()            if valid is False:                raise StatisticsServiceException(msg)            uow.statistics.add(model)            uow.commit()        except Exception as ex:            self.__storage.remove()            raise ex        return model    def delete(self,uow, model):        self.__storage = Storage(model.file.checksum)        res = uow.statistics.delete(model.id)        if res < 1:            raise StatisticsServiceException('Cannot delete statistics ' + model.id)        self.__storage.remove()        if self.__storage.exist():            raise StatisticsServiceException('Cannot delete statistics ' + model.id)        uow.commit()    def __processDataFrame(self,df):        df = self.__autoCast(df)        result = []        for key, value in df.items():            hist =  self.__storage.generateUrl(self.__generateHistogram(df[key])) \            if self.__canGenerateHistogram(df.dtypes[key]) else None            colData = { 'name' : key, 'stats' : self.__generateStats(df[key]),                       'type' : df[key].dtype.__str__(), 'histogram' : hist}            result.append(colData)        return result    def __generateStats(self, df):        stats  = json.loads(df.describe().to_json())        if df.dtype.name == 'int64' or df.dtype.name == 'float64':            stats = {**stats, "median": df.median()  }        if df.dtype.name == 'datetime64[ns]':            stats = {**stats, "min": str(df.min()), 'max' :  str(df.max()) }        stats = { **stats, 'NA' : int(df.isna().sum()), 'null' : int((df.isnull().sum())) }        return stats    def __canGenerateHistogram(self,dtype):        return dtype.name in ['int64', 'float64', 'bool','category']    def __generateHistogram(self,df):        id = uuid.uuid4().__str__()        fileName = secure_filename(df.dtype.name + "-" + id + ".png")        fullpath = self.__storage.generateSystemPath(fileName)        if df.dtype == 'bool':            df = df.astype(int)        df.hist()        plt.suptitle(df.name)        plt.savefig(fullpath)        plt.cla()        plt.clf()        return fileName    def __loadDataFrames(self, filePath, separator):        df = pd.read_csv(filePath, encoding='UTF-8',sep=separator)        if len(df.index) > Statistics.MAX_ROW or len(df.columns) > Statistics.MAX_COLUMN:            raise StatisticsServiceException("Too many row or column")        return df    def __autoCast(self, df):        for col in df.columns:            if df[col].dtype == 'object':                try:                    df[col] = pd.to_datetime(df[col])                except ValueError:                    pass            if df[col].dtype == 'int64' and df[col].min() == 0 and df[col].max() == 1 and df[col].nunique() == 2:                try:                    df[col] = df[col].astype(bool)                except ValueError:                    pass        return df